---
title: 「翻译」比特币：点对点电子现金系统
date: 2018-04-10 21:29:48
tags: 
  - 翻译
---

> 原著 [Satoshi Nakamoto](satoshin@gmx.com)
> 
> 出处 [Bitcoin.org](https://www.bitcoin.org)

## 概述

本文提出了一种完全的通过点对点技术实现的电子现金系统，它使得在线支付能够直接由一方发起并支付给另一方，在此过程中，不需要通过任何的金融机构。虽然数字签名能够解决部分问题，但是如果仍需要可信的第三方才能防止双重支付的话，那么这种系统也就失去了存在价值。我们提供了一种解决方案，它能保证现金系统在点对点的环境下，防止出现双重支付问题。通过随机散列对全部交易加上时间戳，将它们合并入一个不断延伸的基于随机散列的工作量证明的链条作为交易记录，除非重新完成所有的工作量证明，否则形成的交易记录将不能被更改。最长的链条不仅被作为被观察到的事件序列，也被看作是来自 CPU 计算能力的最大池。只要节点上的大多数 CPU 计算能力都不打算合作起来供给全网，那么诚实的节点将会生成最长的、超过攻击者的链条。这个网络本身需要很少的设施。信息尽最大的努力在全网广播，节点可以随时离开或者重新加入网络，并将最长的工作量证明作为该节点离线期间发生的交易的证明。

## 1. 简介

互联网上的贸易，几乎都需要借助于金融机构作为可信的第三方来处理电子支付信息。虽然这种系统对于大多数的交易来说，都能运作良好，但是它的内部仍然受制于「基于信用模型」的弱点。因为金融机构不可避免的会出面调解纠纷，目前，我们仍然无法实现完全不可逆的交易。金融机构的存在，会增加交易的成本，并且限制了最小的可行的交易规模和日常的小额交易。并且潜在的损失还在于，很多的商品和服务是无法退货的，如果缺乏了不可逆的支付手段，那么互联网的交易规模就大大的受限了。因为存在潜在的退款的可能，就需要交易双发互相信任。商家必须提防他们的顾客，因此需要向客户索取必须要的个人信息。在实际的商业活动中，存在着一定比例的欺诈行为是不可避免的。但是在使用纸币现金的情况下，不确定的销售和支付问题是可以避免的，因为此时不存在第三方信用中介来传递交易信息。

所以，我们急切需要一个电子支付系统，它基于密码学而不是信用，使得达成一致的双方能够直接交易，而不需要第三方中介的参与。杜绝回滚支付交易的可能，这样就可以保护卖家免于欺诈，而对于保护买家来说，也是非常方便的，在此环境下设立的第三方担保机制也可谓是非常轻松。在这篇文章中，我们提出了一种通过点对点分布式的时间戳服务器来生成依照时间顺序排列并加以记录的电子证明，用来解决双重支付的问题。只要诚实的节点所控制的计算能力总和大于有合作关系的攻击者的计算机能力的总和，该系统就是安全的。

## 2. 交易

我们定义，一枚电子货币作为一串数字签名。每一位所有者通过对前一次交易和下一位拥有者的公钥进行随机散列签署数字签名，并将这个签名附在这枚电子货币的末尾，电子货币也就发送给了下一位所有者。收款人能够通过对签名进行校验，就能验证该链条的所有者。

![](https://i.loli.net/2018/04/12/5acee443c7b39.jpg)

该过程的问题是，收款人将无法验证之前的所有者是否对这枚电子货币进行了双重支付。通常的解决方案，就是引入一个可信的第三方机构，或者类似于造币厂的结构，对每一笔交易进行校验，用于防止双重支付。每一笔交易结束后，这没电子货币就需要被造币厂回收，造币厂将发行一枚新的电子货币；而只有造币厂直接发行的电子货币，才算做是有效的。可是该方案的问题在于，整个货币系统的核心在于完全依赖于造币厂，因为每一笔交易都需要经过该造币厂的确认，而它所扮演的角色就如同银行。

收款人需要有某种方法，用于确保之前的所有者没有对更早发生的交易实施签名。为了达到这种目的，我们实际上只需要关注的只是在本交易之前发生的交易，而不需要关注这笔交易之后是否会发生双重支付。为了确保某一次交易是否存在，唯一的方法是得到之前发生过的所有交易。在造币厂模型中，造币厂知道所有的交易，并且决定了交易完成的先后顺序。如果在不需要可信赖的第三方机构的情况下，完成类似造币厂的功能，那么需要交易信息被公开宣布，我们需要整个系统内的所有参与者，都有唯一公认的历史交易序列。收款人需要确保在每个交易期间，绝大多数的节点都认同该交易是首次出现的。

## 3. 时间戳服务器

该问题的解决方案，首先提出了一个时间戳服务器概念。时间戳服务器通过对一组以区块链形式存在的并加上时间戳的一组数据进行随机散列，然后将随机散列进行广播，就像报纸或者新闻组织的发帖一样。显然，时间戳能够证明某数据在某个时间必然是存在的，因为只有存在了，才能获取到随机散列的值。每一个时间戳包含了随机散列后的前一个时间戳，每一个随后的时间戳都对前一个时间戳进行了加强，这样，形成了链条。

![](https://i.loli.net/2018/04/12/5acf77f0368a6.jpg)


## 4. 工作量证明

为了在点对点基础上构建分布式的时间戳服务器，仅仅像报纸或者新闻网络组织一样的工作是不够的，我们还需要引入一个类似于 Adam Back 提出的哈希现金。工作量机制引入了对某特定值的扫描工作，比如说 SHA - 256 下，随机散列值以一个或多个0 开始。随着数目的增多，找到这个随机散列解的工作量将曾指数增长，而对结果进行校验仅需要有一个随机散列运算。

为了使时间戳网络可行，我们需要增加一个随机数到数据块中并需要一定的工作量来找到它，这个数据块的哈希已经包含了所需数量的  0 字节。CPU 的处理能力已经被证实满足了所需的工作量，除非重做所有的工作，否则无法修改该数据块。随后的数据块被链接在其后，修改数据块的信息需要把其后所有的数据块的工作量进行重做。

![](https://i.loli.net/2018/04/16/5ad465ed5a55d.jpg)

这个工作量系统也解决了集体决策谁代表大多数的问题。如果大多数是基于一个 IP 地址一票的机制，它将能被分配大量 IP 地址的人所破坏。工作量证明是基于 CPU 一票的。大多数决策被最长的链所代表，也就是代表了最大工作量的投入。如果大多数 CPU 被诚实节点控制，诚实链的增长速度最快，超过任何竞争的链。修改一个过去的块，攻击者必须将块和块之后的所有工作重做，并追上超过诚实节点的工作。我们将随后展示一个慢攻击者追上随后的数据块的可能性岁数据块的增加呈指数增加。

为了抵偿硬件增加的速度和界定啊运行时的变化的收益，工作量证明将被一个移动的平均值来确定，即每小时平均生成的数据块数。如果他们生成的过快，难度也将更难。

## 5. 网络

运行这个网络的步骤：

1. 新的交易广播给所有的节点
2. 每一个节点搜集新的交易，并写进一个数据块
3. 每一个节点发现这个数据块的工作量难度
4. 当一个节点证明了它的工作量，它将广播这个数据块给所有的节点
5. 节点接受这个数据块，只有数据块所有的交易都是有效的并且没有被支付过，节点才会接受这个数据块
6. 如果节点接受了这个数据块，它将创建下一个数据块在数据链上，同时把发送节点数据的哈希作为创建数据块的上一个哈希。

节点始终认为最长的数据链是正确的，会一直在上面进行延伸。如果两个节点广播不同版本的数据块，一个基点先接收到一个或者另一个。在这种情况下，他们会先在第一个接收到的数据库爱上开始工作，但是存储另一个作为下一个分支防止它变得更长。当工作量网络发现其中一个分支变得更长，在短链上工作的节点将会切换到更长的链上，其所属的关系也将会被打断。

新的交易广播不需要达到所有的节点，他们只需要尽可能地达到多的节点，它们将被整合进数据块中。数据块广播容忍丢弃的信息。如果一个节点没有接收到一个数据块，它将持续请求它，知道它接收到下一个数据块，并相信它是丢失的那个。

## 6. 激励

根据约定，每一个区块的第一笔交易都是一个特别的交易，它将产生一枚由此数据块的拥有者拥有的新的货币。这对支持网络的节点有一种激励，同时提供了一种将电子货币分配到流通领域的方法，没有中央集权管理机构去影响他们。稳定地、持续地添加一定数量的新货币类似于消耗资源挖金矿并将黄金注入到流通领域。此时，CPU 的时间和电力消耗就是消耗的资源。

激励也可以通过交易费用来获得。如果一个交易的输出值小于输入值，其中的差值便是交易费，它被作为激励被添加进包含这个交易的数据块。只要既定数量的电子货币进行了流通，那么激励机制就可以组件转换为完全依靠交易费，那么本货币系统将能够免于通货膨胀。

激励机制也有助于鼓励节点保持诚实。如果有一个贪婪的节点能够调集比所有诚实节点加起来还要更多的 CPU 计算能力，它将面临两个选择：要么选择从自己的交易里欺诈别人，要么使用它产生新的货币。他应该发现：按照规则行事，诚实工作将能够得到更多的收益。因为这样的规则有利于联合其他人赚取新货币，超过了他削弱这个系统和损害自身的财富健康的有效性。

## 7. 回收硬盘空间

如果最新的交易已经被足够多的数据块所覆盖，那么就可以丢弃该交易之前的数据，以节省磁盘空间。为了在不打断数据块的随机散列值的情况下促进它，交易被构建成一种 Merkle 树的形态，使得只有根被纳入了区块的随机散列值之中。老的数据块可以被压缩进树的分支之下。内部的随机散列值就不必保存了。

![](https://i.loli.net/2018/04/18/5ad71259eedc8.jpg)


不含交易信息的区块头大小仅有 80 字节。如果我们设定区块生成的速率 1 / 10 min，那么每一年生产的数据为 4.2 MB（80 * 6 * 24 * 365 = 4.2 MB）。2008 年，电脑系统通常的内存容量为 2 GB，根据摩尔定律预测，每年增长 1.2 GB，即使将全部的区块头存储于内存之中都不是问题。

## 8. 简化的支付确认

在不需要运行完整的网络节点的情况下，也有可能进行支付校验。一位用户只需要保留最长的工作量证明链条的区块头的拷贝，他可以不断地向网络发起询问，直到他确信自己拥有最长的链条，并且包含时间戳交易的数据块已经被 Merkle 分支连接上。节点不能检查自己本身自己的交易，但是通过连接到链的某个位置，他能看到网络节点已经接收了这个数据，并且其后增加的数据块也证明了网络节点已经接收了它。

![](https://i.loli.net/2018/04/18/5ad714dd480bb.jpg)

在这种情况下，只要诚实的节点控制了网络，校验机制就是可靠的。但是，如果网络被一个算力占优的攻击者攻击时，它也将变得非常的脆弱。因为网络节点能够自行确认交易的有效性，只要攻击者能够持续地保持计算能力，简化的机制将会被攻击者转接到交易欺骗。那么一个可行的策略是，只要发现了一个无效的区块，就立刻发出警报，收到警报的用户将立刻开始下载被警告的有问题的区块或交易的完整信息，以便对信息的不一致进行判定。对于日常会发生大量收付的商业机构，可能仍会希望运行他们自己的完整的节点，以保持较大的独立完整性和校验的快速性。

## 9. 价值的组合和切割

虽然能单独地对每一个电子货币进行处理，但是对于每一枚电子货币单独发起一次交易将是一种笨拙的方法。为了使价值易于组合与分割，交易可以容纳多个输入与输出。一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：一个用于支付；另外一个用于找零（如果有的话）。

![](https://i.loli.net/2018/04/18/5ad7485da66bc.jpg)

需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制不需要展开校验之前发生的所有交易历史。

## 10. 隐私

传统的造币厂模型为交易的参与者提供了一定程度的隐私保护，因为试图向可信任的第三方索取交易信息是严格受限的。但是如果将交易信息向全网进行广播，就意味着这样的方法失效了。但是隐私依然可以得到保护：将公钥保持为匿名。公众得知的信息仅仅是有某个人将一定数量的货币发给了另外一个人，但是难以将该交易同特定的人联系在一起，也就是说，公众难以确信，这些人究竟是谁。这同股票交易所发布的信息是类似的，股票交易发生的时间、交易量是记录在案并且可供查询的，但是交易双方的身份信息确实不予泄露的。

![](https://i.loli.net/2018/04/18/5ad749f7c3787.jpg)

作为额外的预防措施，使用者可以让每次交易都生成一个新的地址，以确保这些交易不被追溯到一个共同的所有者。但是由于并行输入的存在，一定程度上的追溯还是不可避免的，因为并行输入表明这些货币都属于同一个所有者。此时的风险在于，如果某个人的某一公钥被确认属于他，那么就可以追溯出此人的其他很多交易。

## 11. 计算

我们设想如下的场景：一个攻击者试图比诚实节点更快地产生链条来替换区块链。即便它达到了这一个目的，但是整个系统也并非就此完全受制于攻击者的独断意志了，比方说凭空创造价值，或者掠夺本不属于攻击者的货币。这是因为节点将不会接受无效的交易，而诚实的节点永远不会接受一个包含了无效信息的区块。一个攻击者能做到的，最多是更改他自己的交易信息，并试图拿回他刚刚付给别人的钱。

诚实链条和攻击者链条之间的竞赛，可以用二叉树随机漫步来描述。成功事件定义为诚实链条延长了一个区块，使其领先性 +1，而失败事件则是攻击者的链条被延长了一个区块，使得差距 -1。

攻击者成功填补某一既定差距的可能性，可以近似地看做赌徒破产问题。假定一个赌徒拥有无限的透支信用，然后开始进行潜在次数味无穷的赌博，试图填补上自己的亏空。那么我们可以计算他填不上空缺的概率，也就是该攻击者赶上诚实链条，如下所示：

![](https://i.loli.net/2018/04/18/5ad754bd0447b.jpg)

假定 `p > q`，那么攻击成功的概率就因为区块数的增长而呈现指数化下降。由于概率是攻击者的敌人，如果他不能幸运且快速地获得成功，那么他获得成功的机会随着时间的流逝变得愈发渺茫。那么我们考虑一个收款人需要等待多长时间，才能足够确信付款人已经难以更改交易了。我们假设付款人是一个支付攻击者，希望让收款人在一段时间内相信他已经付过款了，然后立即将支付的款项重新支付给自己。虽然收款人届时会发现这一点，但为时已晚。

收款人生成了新的一对秘钥组合，然后只预留了一个较短的时间将公钥发送给付款人。这将可以防止以下情况：付款人预先准备好一个区块链，然后持续地对此区块进行运算，直到运气让他的区块链超越了诚实链条，方才立即执行支付。当此情形，只要交易一旦发出，攻击者就开始秘密地准备了一条包含了该交易替代版本的平行链条。

然后，收款人将等待交易出现在首个区块中，然后在等到 z 个区块链接其后。此时，他仍然不能确切知道攻击者已经进展了多少个区块，但是假设诚实区块将消耗平均预期时间以产生一个区块，那么攻击者的潜在进展就是一个泊松分布，分布的期望值为：

![](https://i.loli.net/2018/04/19/5ad76d33b3ef6.jpg)

当此情形，为了计算攻击者追赶上的概率，我们减公告记者取得进展区块数量的泊松分布的概率密度，乘以在该数量下攻击者依然能够追赶上的概率。

![](https://i.loli.net/2018/04/19/5ad76d344bbc2.jpg)

化为如下形式，避免对无限数列求和：

![](https://i.loli.net/2018/04/19/5ad76d33e2c83.jpg)

写为如下 C 语言结构：

```c
#include double AttackerSuccessProbability(double q, int z)
{
double p = 1.0 - q;
double lambda = z * (q / p);
double sum = 1.0;
int i, k;
for (k = 0; k <= z; k++)
{
    double poisson = exp(-lambda);
    for (i = 1; i <= k; i++)
        poisson *= lambda / i;
    sum -= poisson * (1 - pow(q / p, z - k));
}
return sum;
}
```

对其进行运算，我们可以得到如下的概率结果，发现概率对 z 值呈指数下降。

当 q = 0.1 时

z=0  P=1.0000000

z=1  P=0.2045873

z=2  P=0.0509779

z=3  P=0.0131722

z=4  P=0.0034552

z=5  P=0.0009137

z=6  P=0.0002428

z=7  P=0.0000647

z=8  P=0.0000173

z=9  P=0.0000046

z=10 P=0.0000012
   
当 q = 0.3 时

z=0  P=1.0000000

z=5  P=0.1773523

z=10 P=0.0416605

z=15 P=0.0101008

z=20 P=0.0024804

z=25 P=0.0006132

z=30 P=0.0001522

z=35 P=0.0000379

z=40 P=0.0000095

z=45 P=0.0000024

z=50 P=0.0000006

求解，令 P < 0.1% 的 z 值：

为使 P < 0.001，则

q=0.10 z=5
q=0.15 z=8
q=0.20 z=11
q=0.25 z=15
q=0.30 z=24
q=0.35 z=41
q=0.40 z=89
q=0.45 z=340

## 12. 结论

我们在此提出了一种不需要信用中介的电子支付系统。我们首先讨论了通常的电子货币的电子签名原理，虽然这种系统为所有权提供了强有力的控制，但是不足以防止双重支付。为了解决这个问题，我们提出了一种采用工作量证明机制的点对点网络来记录交易的公开信息，只要诚实的节点能够控制绝大多数的CPU计算能力，就能使得攻击者事实上难以改变交易记录。该网络的强健之处在于它结构上的简洁性。节点之间的工作大部分是彼此独立的，只需要很少的协同。每个节点都不需要明确自己的身份，由于交易信息的流动路径并无任何要求，所以只需要尽其最大努力传播即可。节点可以随时离开网络，而想重新加入网络也非常容易，因为只需要补充接收离开期间的工作量证明链条即可。节点通过自己的CPU计算力进行投票，表决他们对有效区块的确认，他们不断延长有效的区块链来表达自己的确认，并拒绝在无效的区块之后延长区块以表示拒绝。本框架包含了一个P2P电子货币系统所需要的全部规则和激励措施。

